<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0" />
    <title>Backtrader Advanced JS Chart</title>
    <!-- TradingView Lightweight Charts Standalone JS Library -->
    <script type="text/javascript" src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body {
            padding: 0;
            margin: 0;
            background-color: #131722; /* Dark background for the whole page */
            display: flex;
            flex-direction: column; /* Stack chart containers vertically */
            min-height: 100vh; /* Ensure body takes at least full viewport height */
            overflow-y: auto; /* Allow vertical scrollbars if content overflows */
            color: #D9D9D9; /* Default text color */
            font-family: 'Trebuchet MS', sans-serif;
        }

        .chart-pane {
            width: 100%;
            position: relative; /* For potential absolutely positioned children */
            border-top: 1px solid #2B2B43; /* Separator line */
        }
        #mainChartContainer {
            flex: 0.8; /* Main chart takes 50% height initially, adjust as needed */
            border-top: none; /* No border on the very top chart */
        }
        /* Subchart heights will be managed by flex property set in JS */

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 9999;
            display: block; /* Initially visible */
        }
        /* Simple legend style (can be enhanced) */
        .lw-chart-legend {
            position: absolute;
            left: 12px;
            top: 12px;
            z-index: 1; /* Below crosshair/tooltips */
            font-size: 11px;
            line-height: 16px;
            pointer-events: none; /* Allow clicks to pass through to chart */
        }

        /* Styles for Backtest Report Area */
        #backtestReportArea {
            padding: 15px; /* Reduced padding */
            color: #D9D9D9;
            background-color: #181A20; /* Slightly different background */
            font-size: 0.9em; /* Slightly smaller font for the report */
            border-top: 1px solid #2B2B43; /* Separator from charts */
        }
        .report-section {
            margin-bottom: 15px; /* Reduced margin */
        }
        .report-section h3 {
            color: #4e8df5; /* Accent color for headers */
            margin-top: 0;
            margin-bottom: 8px; /* Reduced margin */
            font-size: 1.1em;
        }
        .report-section dl {
            margin-left: 0;
            padding-left: 0;
        }
        .report-section dt {
            font-weight: bold;
            color: #b0b8c2; /* Lighter color for terms */
            width: 200px; /* Fixed width for terms */
            float: left;
            clear: left;
            margin-bottom: 4px; /* Reduced margin */
        }
        .report-section dd {
            margin-left: 210px; /* Align definitions */
            margin-bottom: 4px; /* Reduced margin */
            color: #D9D9D9;
        }
        .report-section table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 8px; /* Reduced margin */
        }
        .report-section th, .report-section td {
            border: 1px solid #2B2B43; /* Match chart grid color */
            padding: 6px; /* Reduced padding */
            text-align: left;
        }
        .report-section td:first-child {
            font-weight: bold;
            color: #b0b8c2; /* Lighter color for table labels */
            width: 40%; /* Adjust width for label column */
        }
    </style>
</head>
<body>
    <div id="loading">Loading chart data...</div>

    <!-- Main Chart Container -->
    <div id="mainChartContainer" class="chart-pane"></div>

    <!-- Area where subcharts will be dynamically added -->
    <div id="subchartsArea" style="display: flex; flex-direction: column; flex-grow: 1;"></div>

    <!-- Backtest Report Area -->
    <div id="backtestReportArea" style="padding: 10px; color: #D9D9D9;">
        <div id="reportRunConfig"></div>
        <div id="reportPerformanceSummary"></div>
        <div id="reportTradeStats"></div>
    </div>

    <script type="text/javascript">
        const mainChartDiv = document.getElementById('mainChartContainer');
        const subchartsAreaDiv = document.getElementById('subchartsArea');
        const loadingDiv = document.getElementById('loading');

        const commonChartOptions = {
            layout: {
                background: { color: '#131722' },
                textColor: '#D9D9D9',
                fontSize: 11, // Smaller font for scales
                fontFamily: 'Trebuchet MS',
            },
            grid: {
                vertLines: { color: '#2B2B43' },
                horzLines: { color: '#2B2B43' },
            },
            timeScale: {
                timeVisible: true,
                secondsVisible: false,
                borderColor: '#484848',
                rightOffset: 5, // Add some space on the right
            },
            crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal,
                vertLine: { style: LightweightCharts.LineStyle.Dashed, color: '#758696' },
                horzLine: { style: LightweightCharts.LineStyle.Dashed, color: '#758696' },
            },
            rightPriceScale: { // Default for main chart
                borderColor: '#484848',
            }
            // Handle localization if needed:
            // localization: { locale: navigator.language }
        };

        // --- Initialize Main Chart ---
        const mainChart = LightweightCharts.createChart(mainChartDiv, {
            ...commonChartOptions,
            width: mainChartDiv.clientWidth,
            height: mainChartDiv.clientHeight, // Initial, will be adjusted by flex
        });
        // Use addCandlestickSeries instead of the generic addSeries
        const mainCandlestickSeries = mainChart.addCandlestickSeries({
            upColor: '#26A69A', downColor: '#EF5350',
            wickUpColor: '#26A69A', wickDownColor: '#EF5350',
            borderVisible: false,
        });

        // Store subchart instances and their series
        let subchartInstances = {}; // key: pane_id, value: { chart: chartJsObject, seriesMap: {} }
        let allChartObjectsForSync = [mainChart]; // For synchronizing time/crosshair

        // --- Helper to create/get subchart ---
        function getOrCreateSubchart(paneId, numSubchartsTotal) {
            if (!subchartInstances[paneId]) {
                const subDiv = document.createElement('div');
                subDiv.id = `subchart_pane_${paneId}`;
                subDiv.className = 'chart-pane';
                // Distribute remaining space among subcharts
                const remainingFlex = 1.0 - parseFloat(mainChartDiv.style.flex || 0.5);
                const flexPerSub = numSubchartsTotal > 0 ? remainingFlex / numSubchartsTotal : 0.1; // Avoid 0
                subDiv.style.flex = `${Math.max(0.1, flexPerSub)}`; // Min height for visibility
                subchartsAreaDiv.appendChild(subDiv);

                const newSubchart = LightweightCharts.createChart(subDiv, {
                    ...commonChartOptions,
                    width: subDiv.clientWidth,
                    height: subDiv.clientHeight, // Initial, flex will adjust
                    timeScale: { ...commonChartOptions.timeScale, visible: false }, // Hide subchart time axis
                    rightPriceScale: { borderColor: '#484848' },
                });
                subchartInstances[paneId] = { chart: newSubchart, seriesMap: {} };
                allChartObjectsForSync.push(newSubchart);
                console.log(`Created subchart for pane: ${paneId}`);
            }
            return subchartInstances[paneId].chart;
        }

        // --- Sync Functions ---
        function setupSync(chartsToSync) {
            if (chartsToSync.length < 2) return;

            chartsToSync.forEach(sourceChart => {
                const otherCharts = chartsToSync.filter(c => c !== sourceChart);

                sourceChart.timeScale().subscribeVisibleLogicalRangeChange(range => {
                    if (range) {
                        otherCharts.forEach(target => target.timeScale().setVisibleLogicalRange(range));
                    }
                });

                sourceChart.subscribeCrosshairMove(param => {
                    if (param.time) {
                        otherCharts.forEach(target => {
                            // Find the series on the target chart to get price.
                            // This is a simplified crosshair sync based on time.
                            // It won't show the price on the crosshair of other charts unless
                            // there's a series at that exact time to derive a price from.
                            // For simple line series, it might find one.
                            let priceOnTarget = 0; // Default price if not found
                            if (param.seriesData) { // Check if seriesData exists on param
                                 // This part is tricky because param.seriesData is a Map of series on the *source* chart.
                                 // We need to find a corresponding point on the *target* chart series.
                                 // For basic time sync, just move the crosshair time.
                            }
                            target.setCrosshairPosition?.(priceOnTarget, param.time, null); // The 'null' for series is important
                        });
                    } else { // Clear crosshairs on other charts if source is cleared
                        otherCharts.forEach(target => target.clearCrosshairPosition?.());
                    }
                });
            });
        }


        // Fetch data and populate charts
        fetch('/api/chart_data')
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    loadingDiv.innerText = `API Error: ${data.error}`;
                    console.error("Error fetching chart data:", data.error);
                    return;
                }
                console.log("Data received for plotting:", data);

                if (data.data0_ohlc && data.data0_ohlc.length > 0) {
                    mainCandlestickSeries.setData(data.data0_ohlc);

                    // Plot buy/sell signals as markers
                    if (data.trade_signals && data.trade_signals.length > 0) {
                        // Filter out signals with invalid timestamps
                        const validTradeSignals = data.trade_signals.filter(signal => signal.time);

                        const mappedTradeSignals = validTradeSignals.map(signal => ({
                            time: signal.time, // Ensure this is a UNIX timestamp or 'YYYY-MM-DD'
                            position: signal.type === 'buy' ? 'belowBar' : 'aboveBar',
                            color: signal.type === 'buy' ? '#2196F3' : '#e91e63', // Blue for buy, Red for sell
                            shape: signal.type === 'buy' ? 'arrowUp' : 'arrowDown',
                            text: signal.type === 'buy' ? 'Buy' : 'Sell' // Optional: add text
                        }));
                        // console.log("Mapped trade signals for markers:", mappedTradeSignals);
                        if (mainCandlestickSeries && mappedTradeSignals.length > 0) {
                            // Set markers directly on the candlestick series
                            mainCandlestickSeries.setMarkers(mappedTradeSignals);
                            console.log("Trade signal markers set on mainCandlestickSeries.");
                        } else {
                            if (!mainCandlestickSeries) console.error("mainCandlestickSeries is not defined when trying to set markers.");
                            if (mappedTradeSignals.length === 0) console.log("No valid trade signals to map to markers.");
                        }
                    } else {
                        console.log("No trade signals data found or it is empty.");
                    }

                } else { console.warn("No Data0 OHLC to plot."); }

                // Calculate number of unique subchart panes needed for dynamic height allocation
                const subchartPaneIds = new Set();
                if (data.indicator_configs) {
                    data.indicator_configs.forEach(cfg => {
                        if (cfg.target_pane !== 'main') subchartPaneIds.add(cfg.target_pane);
                    });
                }
                 // Also consider Data1 and PortfolioValue for subchart count if they are not in indicator_configs
                if (data.data1_line && data.data1_line.length > 0 && !subchartPaneIds.has('data1_pane')) { // Assuming a fixed pane id
                    subchartPaneIds.add('data1_pane');
                }
                if (data.portfolio_value_line && data.portfolio_value_line.length > 0 && !subchartPaneIds.has('value_pane')) {
                    subchartPaneIds.add('value_pane');
                }
                const numUniqueSubcharts = subchartPaneIds.size;


                // --- Plot Data1 Line (fixed subchart or from indicator_configs) ---
                // Only attempt to plot if data1_line has data
                if (data.data1_line && data.data1_line.length > 0) {
                    const data1PaneId = 'data1_pane'; // Or get from indicator_configs if it's there
                    
                    // Ensure this paneId was added to subchartPaneIds if it wasn't already by an indicator
                    // This is important for the getOrCreateSubchart height calculation
                    if (!subchartPaneIds.has(data1PaneId)) {
                        // This case should ideally be handled when subchartPaneIds is initially populated
                        // For robustness, we could add it here, but it might slightly mess with height
                        // if numUniqueSubcharts was already used.
                        // Best practice: ensure data1_pane is added to subchartPaneIds earlier if data1_line exists.
                        // The existing logic for subchartPaneIds already does this:
                        // if (data.data1_line && data.data1_line.length > 0 && !subchartPaneIds.has('data1_pane')) {
                        //     subchartPaneIds.add('data1_pane');
                        // }
                        // So, numUniqueSubcharts should be correct.
                    }

                    const targetChartD1 = getOrCreateSubchart(data1PaneId, numUniqueSubcharts);
                    if (targetChartD1) { // Check if subchart was successfully created
                        const d1Line = targetChartD1.addLineSeries({
                            title: data.data1_line_name || "Data 1 Close", // Use name from data if provided
                            color: 'orange', lineWidth: 1.5, lastValueVisible: true
                        });
                        d1Line.setData(data.data1_line);
                        console.log("Plotted Data1 line.");
                    } else {
                        // This case should not happen if getOrCreateSubchart is robust
                        console.error("Failed to create or get subchart for Data1 line.");
                    }
                } else { 
                    console.log("No Data1 line data provided or data is empty.");
                }

                // --- Plot Portfolio Value Line (fixed subchart or from indicator_configs) ---
                if (data.portfolio_value_line && data.portfolio_value_line.length > 0) {
                    const valuePaneId = 'value_pane';
                    const targetChartVal = getOrCreateSubchart(valuePaneId, numUniqueSubcharts);
                    // Use addLineSeries instead of the generic addSeries
                    const valLine = targetChartVal.addLineSeries({
                        title: "Portfolio Value",
                        color: 'green', lineStyle: LightweightCharts.LineStyle.Dashed, lineWidth: 2, lastValueVisible: true
                    });
                    valLine.setData(data.portfolio_value_line);
                    console.log("Plotted Portfolio Value line.");
                } else { console.warn("No Portfolio Value line data."); }


                // --- Dynamically Plot Indicators ---
                if (data.indicator_configs && data.indicator_series) {
                    data.indicator_configs.forEach(config => {
                        const seriesData = data.indicator_series[config.internal_id];
                        if (!seriesData || seriesData.length === 0) {
                            console.warn(`No data for indicator: ${config.display_name}`);
                            return;
                        }

                        let targetChart;
                        if (config.target_pane === 'main') {
                            targetChart = mainChart;
                        } else {
                            targetChart = getOrCreateSubchart(config.target_pane, numUniqueSubcharts);
                        }

                        // Use addLineSeries instead of the generic addSeries
                        const indicatorLine = targetChart.addLineSeries({
                            title: config.display_name,
                            color: config.color || getRandomColor(), // Add color to config or use random
                            lineWidth: config.lineWidth || 1.5,
                            lineStyle: config.lineStyle || LightweightCharts.LineStyle.Solid,
                            priceLineVisible: false, // Usually false for indicators
                            lastValueVisible: true
                        });
                        indicatorLine.setData(seriesData);
                        console.log(`Plotted indicator: ${config.display_name} on pane: ${config.target_pane}`);
                    });
                }
                // --- End Indicator Plotting ---

                setupSync(allChartObjectsForSync); // Setup sync after all charts created

                mainChart.timeScale().fitContent();
                loadingDiv.style.display = 'none';
                window.dispatchEvent(new Event('resize')); // Trigger resize to set chart dimensions

                // --- Populate Backtest Report Summary ---
                if (data.report_data) {
                    populateReportData(data.report_data);
                }

            })
            .catch(error => {
                loadingDiv.innerText = 'Failed to load chart data. Check console.';
                console.error('Error fetching or processing chart data:', error);
            });

        function getRandomColor() { /* ... (same as before) ... */
            const r = Math.floor(Math.random() * 200); const g = Math.floor(Math.random() * 200); const b = Math.floor(Math.random() * 200);
            return `rgb(${r},${g},${b})`;
        }

        function resizeAllCharts() {
            mainChart.resize(mainChartDiv.clientWidth, mainChartDiv.clientHeight);
            Object.values(subchartInstances).forEach(subEntry => {
                // Find the div for this subchart (key is paneId)
                const paneId = Object.keys(subchartInstances).find(key => subchartInstances[key] === subEntry);
                const subDiv = document.getElementById(`subchart_pane_${paneId}`);
                if (subDiv) subEntry.chart.resize(subDiv.clientWidth, subDiv.clientHeight);
            });
        }
        window.addEventListener('resize', resizeAllCharts);
        // Initial resize might be needed after DOM manipulation, give flexbox time
        setTimeout(() => {
            mainChartDiv.style.flex = '0.5'; // Example fixed height for main
            // Re-calculate subchart flex based on how many were actually created
            const actualSubchartsCreated = Object.keys(subchartInstances).length;
            if (actualSubchartsCreated > 0) {
                const remainingFlexForSubs = 1.0 - parseFloat(mainChartDiv.style.flex);
                const flexPerActualSub = remainingFlexForSubs / actualSubchartsCreated;
                 Object.keys(subchartInstances).forEach(paneId => {
                    const subDiv = document.getElementById(`subchart_pane_${paneId}`);
                    if(subDiv) subDiv.style.flex = `${flexPerActualSub}`;
                });
            }
            resizeAllCharts();
        }, 100);

        // --- Helper functions for populating report data ---
        function formatValue(value, type = 'number', decimalPlaces = 2) {
            if (value === null || value === undefined || value === "N/A") return 'N/A';
            if (typeof value === 'string' && (value.toLowerCase() === 'inf' || value.toLowerCase() === 'infinity')) return 'Infinity';
            
            if (typeof value !== 'number' && type !== 'string') return 'N/A'; // Ensure value is a number for numeric types

            switch (type) {
                case 'currency':
                    return value.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 }); // Basic currency, adapt as needed
                case 'percentage':
                    return value.toFixed(decimalPlaces) + '%';
                case 'number':
                    return value.toFixed(decimalPlaces);
                case 'integer':
                    return parseInt(value, 10).toString();
                case 'string':
                    return String(value);
                default:
                    return String(value);
            }
        }

        function appendDlItem(dlElement, term, definition, valueType = 'string', decimalPlaces) {
            const dt = document.createElement('dt');
            dt.textContent = term;
            const dd = document.createElement('dd');
            dd.textContent = formatValue(definition, valueType, decimalPlaces);
            dlElement.appendChild(dt);
            dlElement.appendChild(dd);
        }

        function appendTableRow(tbodyElement, label, value, valueType = 'string', decimalPlaces) {
            const tr = document.createElement('tr');
            const tdLabel = document.createElement('td');
            tdLabel.textContent = label;
            const tdValue = document.createElement('td');
            tdValue.textContent = formatValue(value, valueType, decimalPlaces);
            tr.appendChild(tdLabel);
            tr.appendChild(tdValue);
            tbodyElement.appendChild(tr);
        }

        function populateReportData(reportData) {
            const configDiv = document.getElementById('reportRunConfig');
            const performanceDiv = document.getElementById('reportPerformanceSummary');
            const statsDiv = document.getElementById('reportTradeStats');

            // Clear previous content and add headers
            configDiv.innerHTML = '<h3>Run Configuration</h3>';
            performanceDiv.innerHTML = '<h3>Performance Summary</h3>';
            statsDiv.innerHTML = '<h3>Trade Statistics</h3>';

            if (!reportData || Object.keys(reportData).length === 0) {
                const p = document.createElement('p');
                p.textContent = 'No report data available.';
                // Append to one of the divs, or a general report area
                document.getElementById('backtestReportArea').appendChild(p);
                return;
            }

            // Populate Run Configuration
            if (reportData.run_config) {
                const rc = reportData.run_config;
                const dlConfig = document.createElement('dl');
                appendDlItem(dlConfig, 'Strategy:', rc.strategy_name);
                
                // Improved parameter display
                if (rc.parameters && typeof rc.parameters === 'object' && Object.keys(rc.parameters).length > 0) {
                    const paramsDt = document.createElement('dt');
                    paramsDt.textContent = 'Parameters:';
                    const paramsDd = document.createElement('dd');
                    
                    const paramsUl = document.createElement('ul');
                    paramsUl.style.listStyleType = 'none'; // Optional: remove bullets
                    paramsUl.style.paddingLeft = '0'; // Optional: remove default padding
                    paramsUl.style.marginLeft = '0'; // Align with other dd items if dt is floated

                    for (const key in rc.parameters) {
                        if (Object.prototype.hasOwnProperty.call(rc.parameters, key)) {
                            const li = document.createElement('li');
                            li.innerHTML = `<span style="font-weight:normal; color:#9db2bd;">&nbsp;&nbsp;&nbsp;&nbsp;${key}:</span> ${formatValue(rc.parameters[key], typeof rc.parameters[key] === 'number' ? 'number' : 'string', 2)}`;
                            paramsUl.appendChild(li);
                        }
                    }
                    paramsDd.appendChild(paramsUl);
                    dlConfig.appendChild(paramsDt);
                    dlConfig.appendChild(paramsDd);

                } else {
                    appendDlItem(dlConfig, 'Parameters:', 'N/A');
                }
                
                appendDlItem(dlConfig, 'Data File 1:', rc.data_path_1);
                appendDlItem(dlConfig, 'From Date:', rc.fromdate);
                appendDlItem(dlConfig, 'To Date:', rc.todate);
                configDiv.appendChild(dlConfig);
            }

            // Populate Performance Summary
            if (reportData.performance_summary) {
                const ps = reportData.performance_summary;
                const tablePs = document.createElement('table');
                const tbodyPs = document.createElement('tbody');
                
                appendTableRow(tbodyPs, 'Total Net P&L:', ps.total_net_pnl, 'currency');
                appendTableRow(tbodyPs, 'Max Drawdown:', ps.max_drawdown_pct, 'percentage');
                appendTableRow(tbodyPs, 'Sharpe Ratio:', ps.sharpe_ratio, 'number', 2);
                appendTableRow(tbodyPs, 'SQN:', ps.sqn, 'number', 2);
                
                tablePs.appendChild(tbodyPs);
                performanceDiv.appendChild(tablePs);
            }

            // Populate Trade Statistics
            if (reportData.trade_stats) {
                const ts = reportData.trade_stats;
                const tableTs = document.createElement('table');
                const tbodyTs = document.createElement('tbody');

                appendTableRow(tbodyTs, 'Total Closed Trades:', ts.total_closed_trades, 'integer');
                appendTableRow(tbodyTs, 'Win Rate:', ts.win_rate_pct, 'percentage');
                appendTableRow(tbodyTs, 'Profit Factor:', ts.profit_factor, 'number', 2); // Can be 'Infinity' or 'N/A'
                appendTableRow(tbodyTs, 'Average P&L per Trade:', ts.avg_pnl_per_trade, 'currency');
                appendTableRow(tbodyTs, 'Total Winning Trades:', ts.total_winning_trades, 'integer');
                appendTableRow(tbodyTs, 'Total Losing Trades:', ts.total_losing_trades, 'integer');
                appendTableRow(tbodyTs, 'Average Win P&L:', ts.avg_win_pnl, 'currency');
                appendTableRow(tbodyTs, 'Average Loss P&L:', ts.avg_loss_pnl, 'currency');
                appendTableRow(tbodyTs, 'Max Win P&L (Single Trade):', ts.max_win_pnl, 'currency');
                appendTableRow(tbodyTs, 'Max Loss P&L (Single Trade):', ts.max_loss_pnl, 'currency');
                
                tableTs.appendChild(tbodyTs);
                statsDiv.appendChild(tableTs);
            }
        }

    </script>
</body>
</html>